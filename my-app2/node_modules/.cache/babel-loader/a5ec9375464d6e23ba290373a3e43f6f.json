{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require('babel-runtime/core-js/object/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _types = require('./types');\n\n(0, _keys2.default)(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  (0, _defineProperty2.default)(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _actions = require('./actions');\n\n(0, _keys2.default)(_actions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  (0, _defineProperty2.default)(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _actions[key];\n    }\n  });\n});\nexports.handleActions = handleActions;\n\nvar _handleActions = require('redux-actions/lib/handleActions');\n\nvar _handleActions2 = _interopRequireDefault(_handleActions);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * There is an issue with imports ordering.\n *\n * When you export types A and B (that uses A), if you'll import type B before the A,\n * there will be some strange issues in some cases.\n *\n * This way we 'bound' the type declared in file to force flow use the correct type.\n *\n * TODO: (@lttb) need to open a type issue with a simple example.\n */\n\n/* eslint-disable no-redeclare */\n\n\nfunction handleActions(handlers) {\n  var defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (0, _handleActions2.default)(handlers, defaultState);\n}\n/* eslint-enable no-redeclare */","map":null,"metadata":{},"sourceType":"script"}